---
title: "Day 2 – 01 Explore Data"
author: "Seminar plotting walk-through"
output:
  html_document:
    toc: true
    toc_depth: 2
---

We start the Day 2 session with the already prepared file
`second_day_part2/data/dataset1_subset_long.csv`. This document simply shows how
to open that file with base R commands and how to inspect what is inside before
we move on to plotting. Run `second_day_part2/data/00_prepare_dataset.Rmd`
first if you need to regenerate the CSV. Knit it from the repository root with:

```
R -e "rmarkdown::render('second_day_part2/scripts/01_explore_data.Rmd')"
```

## 1. Load the CSV

```{r load-data}
input_path <- file.path('..', 'data', 'dataset1_subset_long.csv')
long_df <- read.csv(input_path, stringsAsFactors = FALSE, check.names = FALSE)

cat('Rows:', nrow(long_df), '\\nColumns:', ncol(long_df), '\\n')
```

## 2. Look at column names and a small preview

`colnames()` lists the headers exactly as they appear in the CSV and `head()`
prints the first few rows. Encourage learners to read these outputs aloud so
they begin to map column names to real-world meaning (genome name, SNP id,
mouse ID, day, value, ...).

```{r basics}
colnames(long_df)
head(long_df)
```

It can also help to peek at the SNP identifiers themselves to remind everyone
what a typical label looks like:

```{r show-snps}
head(unique(long_df$snp_id), n = 5)
```

## 3. Which genomes are present?

We often start by asking “Which genomes are represented here?”. `unique()`
returns all distinct values, while `table()` counts how many rows belong to
each genome.

```{r genome-info}
unique(long_df$Genome)

table(long_df$Genome)
```

Explain to students that each row contains the `Genome`, the unique SNP id, the
mouse ID, the day of sampling, and the measured value.

## 4. How many SNPs per genome?

Counting the unique SNP identifiers per genome shows how much information we
keep for each organism. The helper `tapply(values, groups, FUN)` applies a
function to each subset of `values` defined by `groups`. Here we give it the
vector of SNP ids and ask it to count how many unique ids (`length(unique(x))`)
exist inside each genome group.

```{r snp-counts}
snp_per_genome <- tapply(long_df$snp_id, long_df$Genome, function(x) length(unique(x)))
snp_per_genome
```

## 6. How many measurements per mouse and per day?

```{r mouse-day}
table(long_df$mouse_id)

table(long_df$day)
```

For a combined view you can also build a two-way table. Again we use `table()`,
this time with `mouse_id` on rows and `day` on columns. Reading across a row
shows how many time points we have for a given mouse.

```{r mouse-day-2way}
table(long_df$mouse_id, long_df$day)
```

Pick any cell and inspect those rows directly. For example, mouse 1683 on day 0
has the following measurements (all SNPs for that mouse/day):

```{r mouse-day-example}
subset_example <- long_df[long_df$mouse_id == '1683' & long_df$day == 0, ]
subset_example
```

## 6. What do the allele-frequency values look like?

Start by focusing on a single genome (Akkermansia) so the histogram is easy to
interpret, then compare it against the combined dataset.

```{r value-hist-akk}
akk_values <- long_df$value[long_df$Genome == 'Akkermansia_muciniphila_YL44']
hist(akk_values, breaks = 20, main = 'Akkermansia allele frequencies', xlab = 'value (allele frequency)')
summary(akk_values)
```

Do the same for Bacteroides (the other genome in this dataset).

```{r value-hist-bact}
bacto_values <- long_df$value[long_df$Genome == 'Bacteroides_caecimuris_I48']
hist(bacto_values, breaks = 20, main = 'Bacteroides allele frequencies', xlab = 'value (allele frequency)')
summary(bacto_values)
```

Now look at the complete long table to see how the mixture of genomes changes the distribution.

```{r value-hist}
hist(long_df$value, breaks = 30, main = 'All genomes: allele-frequency histogram', xlab = 'value (allele frequency)')
summary(long_df$value)
```

To compare genomes explicitly, break the summary down by genome using
`aggregate(value ~ Genome, ...)`. Read `value ~ Genome` as “value grouped by
Genome”. The column on the left must be numeric because we are calling
`summary()` on it.

```{r value-summary-by-genome}
value_by_genome <- aggregate(value ~ Genome, data = long_df, function(x) summary(x))
value_by_genome
```

## 7. How many missing values?

Count how many `NA` values appear in `value` and, if any, locate them by mouse/day.

```{r missing}
na_total <- sum(is.na(long_df$value))
na_total

na_by_mouse_day <- with(long_df, tapply(value, list(mouse_id, day), function(x) sum(is.na(x))))
na_by_mouse_day
```

## 8. Treatment-group overview

The long table now contains a `treatment_group` column. Start by listing the distinct labels and counting how many rows belong to each group.

```{r group-counts}
unique(long_df$treatment_group)
table(long_df$treatment_group)
```

Which treatment groups appear for each mouse? Use a cross-tabulation to reinforce how mice were assigned.

```{r group-by-mouse}
table(long_df$mouse_id, long_df$treatment_group)
```

You can also inspect specific days. For example, day 30 only:

```{r group-by-day}
subset_day30 <- long_df[long_df$day == 30, c('mouse_id', 'treatment_group')]
unique(subset_day30)
```

## 9. Focus on a single genome (Akkermansia)

Subsetting is a great way to answer specific questions. Below we keep only
`Akkermansia_muciniphila_YL44` (using a logical comparison inside the square
brackets) and inspect the resulting table. This demonstrates how to focus on
one organism without altering the original data frame.

Explain that `long_df$Genome == 'Akkermansia_muciniphila_YL44'` evaluates to a
vector of TRUE/FALSE values—TRUE where the genome matches that text and FALSE
everywhere else. When we place that logical vector inside `[...]`, R keeps only
the TRUE rows.

```{r akkermansia}
akk_df <- long_df[long_df$Genome == 'Akkermansia_muciniphila_YL44', ]
cat('Rows for Akkermansia:', nrow(akk_df), '\n')
head(akk_df)

# After subsetting we can still use `table()` to see how measurements are
# distributed for this genome alone.
table(akk_df$mouse_id, akk_df$day)
```

```{r equality-demo}
head(long_df$Genome == 'Akkermansia_muciniphila_YL44')
```

Reading this out loud (“TRUE, TRUE, FALSE, …”) reinforces that the comparison
creates a logical mask; only the TRUE rows survive when we subset with
`[...]`.

Having these quick checks documented makes it easy to reassure learners that we
understand the input file before moving into the plotting notebook
(`second_day_part2/scripts/02_simple_heatmap.Rmd`).
