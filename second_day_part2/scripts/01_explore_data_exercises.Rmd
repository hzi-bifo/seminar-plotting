title: "Day 2 – 01 Explore Data (Exercises)"
author: "Seminar practice worksheet"
output:
  html_document:
    toc: true
    toc_depth: 2
---

This exercise notebook follows the same steps as the guided exploration while
letting you practice independently. It works on
`second_day_part2/data/dataset2_subset_long.csv`, the three-genome version of
the dataset (Akkermansia, Bacteroides, Turicimonas). Type your own code into
the chunks below; the prompts explain what to do and the code blocks are left
with `# TODO` comments so you can fill them in.

> **Tip:** Run `second_day_part2/00_prepare.Rmd` once to install packages, and
> `second_day_part2/data/00_prepare_dataset.Rmd` only if you need to regenerate
> the three-genome dataset.

## 1. Load and preview the dataset

Goal: use `read.csv()` to load the file, then report the number of rows/columns
and display the first few entries.

Think of this as your "sanity check" step. Confirm that the CSV path you expect
actually exists, that the delimiter was read correctly (no shifted columns),
and that the headers align with the guided walkthrough. Printing the first
couple of lines also helps you spot accidental factor conversion or hidden
`stringsAsFactors = TRUE` issues before they propagate into later tasks.

```{r ex1, eval=FALSE}
# TODO: load dataset2_subset_long.csv into an object named long_df
# TODO: print nrow(long_df) and ncol(long_df)
# TODO: call head(long_df)
```

*Hint:* remember to set `stringsAsFactors = FALSE` and `check.names = FALSE` so
the column headers stay untouched.

## 2. Enumerate genomes and SNPs

Goal: list all genomes present, count how many rows each contributes, and count
unique SNP identifiers per genome.

These counts will anchor your interpretation later. If one genome contributes
far more rows, its patterns will dominate simple histograms. Likewise, the SNP
totals tell you whether a genome appears sparse because it has fewer markers or
because of experimental filtering. Capture both the raw row counts and the
unique SNP counts so you can mention them when presenting results.

```{r ex2, eval=FALSE}
# TODO: unique() to list genomes
# TODO: table() to count rows per genome
# TODO: tapply() + length(unique()) to count SNPs per genome
```

*Hint:* model your solution after the formula `tapply(long_df$snp_id,
long_df$Genome, ...)`.

## 3. Summaries by genome

Goal: compute summary statistics of `value` for each genome (min/median/mean,
etc.) using `aggregate(value ~ Genome, ...)`. Also, show a quick `summary()` of
the first few values to illustrate what the anonymous function does.

Interpreting a heatmap gets easier when you already know the numeric range per
genome. Use this section to capture descriptive stats you can reuse in slides or
discussion. Consider storing the aggregated summaries in an object (e.g.,
`genome_summary`) so you can sort by median or compare genomes later without
rerunning the aggregation.

```{r ex3, eval=FALSE}
# TODO: sample_values <- long_df$value[1:10]; summary(sample_values)
# TODO: aggregate(value ~ Genome, data = long_df, function(x) summary(x))
```

*Hint:* read `value ~ Genome` as “value grouped by Genome”. The column to the
left of `~` must be numeric.

## 4. Focus on Turicimonas

Goal: subset the data frame to `Turicimonas_muris_YL45` only, show `head()` of
the subset, and build a `table(mouse_id, day)` for that genome.

Turicimonas is the new genome compared with the two-genome walkthrough, so
spend time understanding its footprint. After filtering, look at which mice and
days have observations—do they align with the treatment timeline? You can also
inspect a few `snp_id`s to see if they cluster by chromosome or appear randomly
distributed.

```{r ex4, eval=FALSE}
# TODO: turicimonas_df <- long_df[long_df$Genome == 'Turicimonas_muris_YL45', ]
# TODO: head(turicimonas_df)
# TODO: table(turicimonas_df$mouse_id, turicimonas_df$day)
```

*Hint:* inspect `head(long_df$Genome == 'Turicimonas_muris_YL45')` to see the
TRUE/FALSE mask created by the comparison.

## 5. Allele-frequency focus (Turicimonas vs all genomes)

Goal: plot the allele-frequency (`value`) histogram for `Turicimonas_muris_YL45`, then for the entire dataset. Report `summary()` for both vectors and note whether Turicimonas shows more high-frequency SNPs.

Go beyond the simple plot: compare medians, interquartile ranges, and extreme
values. If distributions look different, jot down a short interpretation such
as “Turicimonas peaks near 0.4 whereas Akkermansia spans 0–1 evenly.” These
observations will justify why adding a third genome matters in the downstream
heatmap exercise.

```{r ex5, eval=FALSE}
# TODO: turicimonas_values <- long_df$value[long_df$Genome == 'Turicimonas_muris_YL45']
# TODO: hist(turicimonas_values, breaks = 20, main = 'Turicimonas AF', xlab = 'value')
# TODO: summary(turicimonas_values)
# TODO: hist(long_df$value, breaks = 30, main = 'All genomes AF', xlab = 'value')
# TODO: summary(long_df$value)
# Question: Does Turicimonas concentrate at higher or lower allele frequencies compared to the mix?
```

*Hint:* reuse the histogram idea from the guided notebook and jot down your interpretation.

## 6. Missing values

Goal: check whether the `value` column contains any `NA`s overall and per mouse/day combination.

Missing entries often indicate gaps in the sequencing schedule or quality
filters that failed. Calculating `na_total` tells you whether the dataset is
complete, while the `tapply()` step pinpoints exactly which mouse/day pairs are
affected. If you do find `NA`s, note them explicitly so you can exclude or
impute them consistently later.

```{r ex6, eval=FALSE}
# TODO: na_total <- sum(is.na(long_df$value))
# TODO: na_by_mouse_day <- with(long_df, tapply(value, list(mouse_id, day), function(x) sum(is.na(x))))
# TODO: print both objects and interpret (all zeros means no missing data).
```

*Question:* If you do detect NA values, which genome(s) or treatment groups do
they belong to? State explicitly whether Turicimonas introduces any missing
allele frequencies.

## 7. Treatment groups

Goal: use the `treatment_group` column to understand how samples are distributed
across treatments.

Understanding group balance helps when you later draw stratified plots. Capture
the total number of measurements per treatment, how many mice belong to each
group, and whether every day has representation for each treatment. You can
also look for edge cases (e.g., a mouse switching treatments) and document them
here before they confuse you during plotting.

```{r ex7, eval=FALSE}
# TODO: list unique(long_df$treatment_group)
# TODO: table(long_df$treatment_group)
# TODO: table(long_df$mouse_id, long_df$treatment_group)
# TODO: subset long_df for a specific day (e.g., day 30) and inspect treatment groups
```

*Hint:* use `table()` for quick counts and `unique()` to see combinations of
mouse/day/group.

## 8. Stretch idea

Push yourself to answer: “Which genome has the highest median value on day 30?”
Outline your approach below before coding it up.

Treat this like a mini-analysis write-up: define the filter criteria, jot down
which helper functions you will reuse (`tapply`, `aggregate`, or `dplyr`), and
decide how you will report ties. If you have extra time, repeat for another day
or compare medians vs means to see whether outliers influence your conclusion.

```{r ex8-notes, eval=FALSE}
# Notes / pseudo-code:
# 1. Filter long_df to day == 30
# 2. Split by Genome and compute median(value)
# 3. Identify the maximum
```

These practice tasks mirror the guided walkthrough but force you to re-create
the analysis yourself. Once satisfied, continue with
`scripts/02_simple_heatmap.Rmd` to generate the heatmap.
